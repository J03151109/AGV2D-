<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Multi-AGV 搬送シミュレーター（UI強化版）</title>
  <style>
    body { display: flex; font-family: sans-serif; }
    #controls { width: 220px; padding: 10px; border-left: 1px solid #ccc; }
    #main { flex: 1; padding: 10px; }
    canvas { border: 1px solid #aaa; background: #f9f9f9; display: block; margin-bottom: 10px; }
    input, button { margin: 5px 0; width: 100%; }
    h2 { margin-top: 0; }
  </style>
</head>
<body>
  <div id="main">
    <h2>Multi-AGV 搬送シミュレーター</h2>
    <canvas id="simCanvas" width="500" height="500"></canvas>
  </div>
  <div id="controls">
    <label>AGV台数（1-5）：<input type="number" id="agvCount" value="2" min="1" max="5"></label>
    <label>速度（m/min）：<input type="number" id="speed" value="60" min="10" max="200"></label>
    <button onclick="applySettings()">適用</button>
    <button onclick="start()">スタート</button>
    <button onclick="stop()">ストップ</button>

    <hr>
    <h4>操作説明</h4>
    <ul style="font-size: 14px; padding-left: 16px;">
      <li>左クリック：線上をクリックしてルート作成</li>
      <li>右クリック：既にあるルート上の点を削除</li>
      <li>複数AGVが同じルートを走行します</li>
      <li>スタート地点：最初にクリックした地点</li>
      <li>ルートは自動で周回されます</li>
    </ul>
  </div>

  <script>
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 50; // 1マス = 50px = 1m

    let route = [];
    let agvs = [];
    let speed = 60; // m/min
    let moving = false;

    function applySettings() {
      const count = parseInt(document.getElementById("agvCount").value);
      speed = parseInt(document.getElementById("speed").value);
      agvs = [];
      for (let i = 0; i < count; i++) {
        agvs.push({ x: 0, y: 0, index: 0, color: getColor(i), route });
      }
      if (route.length > 0) {
        agvs.forEach(agv => {
          agv.x = route[0].x;
          agv.y = route[0].y;
        });
      }
    }

    function getColor(i) {
      const colors = ["blue", "red", "green", "orange", "purple"];
      return colors[i % colors.length];
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i <= 500; i += gridSize) {
        ctx.strokeStyle = '#ddd';
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 500); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(500, i); ctx.stroke();
      }
    }

    function drawRouteAndAGVs() {
      // 経路
      if (route.length > 0) {
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(route[0].x, route[0].y);
        route.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
      }

      // AGV本体
      agvs.forEach(agv => {
        ctx.fillStyle = agv.color;
        ctx.fillRect(agv.x - 10, agv.y - 10, 20, 20);
      });
    }

    function draw() {
      drawGrid();
      drawRouteAndAGVs();
    }

    function moveAGV(agv) {
      if (route.length < 2) return;
      const current = route[agv.index];
      const next = route[(agv.index + 1) % route.length];
      const dx = next.x - current.x;
      const dy = next.y - current.y;
      const dist = Math.hypot(dx, dy);
      const step = (speed / 60) * (gridSize / 60);
      const vx = (dx / dist) * step;
      const vy = (dy / dist) * step;
      agv.x += vx;
      agv.y += vy;
      if (Math.hypot(agv.x - current.x, agv.y - current.y) >= dist) {
        agv.index = (agv.index + 1) % route.length;
        agv.x = route[agv.index].x;
        agv.y = route[agv.index].y;
      }
    }

    function loop() {
      if (moving) agvs.forEach(moveAGV);
      draw();
      requestAnimationFrame(loop);
    }

    function start() {
      if (route.length < 1) return alert("ルートが設定されていません");
      agvs.forEach(agv => {
        agv.index = 0;
        agv.x = route[0].x;
        agv.y = route[0].y;
      });
      moving = true;
    }

    function stop() {
      moving = false;
    }

    canvas.addEventListener("click", e => {
      if (moving) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left) / gridSize) * gridSize;
      const y = Math.round((e.clientY - rect.top) / gridSize) * gridSize;
      route.push({x, y});
      draw();
    });

    canvas.addEventListener("contextmenu", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left) / gridSize) * gridSize;
      const y = Math.round((e.clientY - rect.top) / gridSize) * gridSize;
      const idx = route.findIndex(p => p.x === x && p.y === y);
      if (idx >= 0) route.splice(idx, 1);
      draw();
    });

    applySettings();
    loop();
  </script>
</body>
</html>
